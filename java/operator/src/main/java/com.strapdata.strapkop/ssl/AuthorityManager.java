package com.strapdata.strapkop.ssl;


import com.strapdata.strapkop.k8s.OperatorLabels;
import com.strapdata.strapkop.ssl.utils.CertManager;
import com.strapdata.strapkop.ssl.utils.X509CertificateAndPrivateKey;
import io.kubernetes.client.ApiException;
import io.kubernetes.client.apis.CoreV1Api;
import io.kubernetes.client.models.V1ObjectMeta;
import io.kubernetes.client.models.V1Secret;
import org.bouncycastle.operator.OperatorCreationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;
import java.security.cert.CertificateException;
import java.text.MessageFormat;

@Singleton
public class AuthorityManager {
    private static final Logger logger = LoggerFactory.getLogger(AuthorityManager.class);
    
    public static final String DEFAULT_SECRET_NAME = "elassandra-operator-ca";
    public static final String SECRET_CERT_PATH = "ca.crt";
    public static final String SECRET_KEY_PATH = "ca.key";
    
    @Inject
    private CertManager certManager;
    
    @Inject
    private CoreV1Api coreApi;
    
    /**
     * Store a CA in a kubernetes secret
     * @param name the name of the secret
     * @param namespace the namespace of the secret
     * @param ca the CA key and certs
     * @throws ApiException
     */
    public void storeAsSecret(String name, String namespace, X509CertificateAndPrivateKey ca) throws ApiException {
        final V1Secret secret = new V1Secret()
                .metadata(new V1ObjectMeta()
                        .name(name)
                        .labels(OperatorLabels.MANAGED))
                .putStringDataItem(SECRET_KEY_PATH, ca.getPrivateKeyAsString())
                .putStringDataItem(SECRET_CERT_PATH, ca.getCertificateChainAsString());
    
        logger.info("Storing default CA in secret {} in namespace {}", name, namespace);
        coreApi.createNamespacedSecret(namespace, secret, null, null, null);
    }
    
    /**
     * Load a CA key and certs from a kubernetes secret
     * @param name the name of the secret
     * @param namespace the namespace of the secret
     * @return the CA key and certs
     * @throws ApiException 404 if it does not exists
     */
    public X509CertificateAndPrivateKey loadFromSecret(String name, String namespace) throws Exception {
        V1Secret secret = coreApi.readNamespacedSecret(name, namespace, null, null, null);
 
        final byte[] certsBytes = secret.getData().get(SECRET_CERT_PATH);
        if (certsBytes == null) {
            throw new Exception(MessageFormat.format("missing file {} from secret {} in namespace {}", SECRET_CERT_PATH, name, namespace));
        }
        final String certs = new String(certsBytes);
        
        final byte[] keyBytes = secret.getData().get(SECRET_KEY_PATH);
        if (keyBytes == null) {
            throw new Exception(MessageFormat.format("missing file {} from secret {} in namespace {}", SECRET_KEY_PATH, name, namespace));
        }
        final String key = new String(keyBytes);
        
        return new X509CertificateAndPrivateKey(certs, key);
    }
    
    /**
     * Generate a new CA key and certs
     */
    public X509CertificateAndPrivateKey generate() throws OperatorCreationException, CertificateException, SignatureException, NoSuchAlgorithmException, IOException {
        logger.info("Generating operator root ca");
        return certManager.generateCa("AutoGeneratedRootCA", null);
    }
    
}
